掉落的不光有鸟儿停歇的树枝，还有从这根树枝上长出的树枝，和从长出的树枝上长出的树枝，
等等。人终其一生，不也正是这样的得失吗？
这棵树上共有 n 根树枝，一些是从树干上长出来的，一些是从别的树枝上长出来的。我们说
树枝 B 在树枝 A 的下方，当且仅当存在一个树枝序列 C1, C2, . . . , Ck 满足 C1 = A、Ck = B，且
对于 1 ≤ i < k，树枝 Ci+1 都是从树枝 Ci 上长出来的。
每根树枝能承载的重量是有限的，记为 w。定义一根树枝的负重为其自身，加上其下方所有
树枝上结出的橡果的数量。如果一根树枝的负重超过了 w 颗橡果，树枝便会折断。折断的将会是
最“靠下”的树枝。举个例子，假设某根树枝上新长出来了若干橡果。如果这根树枝的负重超过了
其所能承载的重量，那么它会折断；否则，考虑长出了这根树枝的树枝，如果其负重超过了其所
能承载的重量，那么它会折断；以此类推。只有当前一个条件不满足时，才会判断后一个条件是
否满足。因此，如果一根树枝被折断，那么其上方所有树枝都不会被折断。特殊地，我们认为树干
所能承载的重量是无限的。
对了，有一点忘说了——这棵树是可持久化的。大厨恐怕记不住每个历史时刻中橡树的状态，
你能帮帮他吗？大厨会告诉你橡树经历的每个事件，你则需要告诉大厨事件之后发生了什么。
输入格式
输入的第一行包含一个整数 T，代表测试数据的组数。接下来是 T 组数据。
每组数据的第一行包含两个整数 n 和 m，分别代表橡树的树枝数量和大厨记下的事件数量。
树枝编号为 1 ∼ n。
接下来 n 行，每行描述一根树枝。第 v 行包含两个整数 pv 和 wv。如果 pv = 0，那么第 v 根
树枝从树干上长出；否则它从第 pv 根树枝上长出。wv 则是第 v 根树枝能承载的重量。
接下来 m 行，每行描述一个事件。事件共有两种：
• state 1 u x：第 u 根树枝上长出了 x 颗橡果；输出事件发生后有这段的树枝的编号，如
果不存在则输出 0；
• state 2 u：一只鸟飞到了第 u 根树枝上，树枝及其下方所有树枝上的橡果掉落；输出掉
落的橡果的数量。
事件描述中的state为事件发生时的状态编号。如果 state = 0，则代表初始状态，即没有树枝折
断，树上也没有橡果。如果 state > 0，则代表第 state 个事件后的状态。
输出格式
对于每个事件，输出一行，包含一个整数，代表该事件对应的输出。

1
5 6
0 5
1 3
0 2
3 1
3 4
0 1 5 5
0 1 4 1
2 1 5 2
2 2 3
4 1 5 2
3 1 1 7



5
0
3
1
0
1

1
5 2
0 5
1 3
0 2
3 1
3 4
0 1 4 1
1 1 5 2